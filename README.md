# compiler-dodecahedron
Dodecahedron programming language compiler

Convert AST into IR
```
(1 + a) * b
    |
    v
    1 + a
     |
     v
    1
       a
```

Program correctness thoughts:
 - A variable can only be used after it has been created. It's lifetime cascades to child blocks. Variable shadowing may not happen in descendant blocks. OBVIOUS
   Implement this by keeping track of created variables and making sure that used variables have been declared before. Have a 'global' hashset and
   let each block have a Vec of their declared variables, and let a block remove it's variables after it has run out.
- Should every AST node have a source reference, like, char range? Yes

TODO: Don't allow nested functions, right now: bad behaviour.

# How to run the things:
Compile when change:

    ls . src/* | entr -c cargo r

Run c program generated by c backend:

    gcc out.c && ./a.out


# run nasm on test.asm (generated by assembly backend):

    nasm -f elf64 -F dwarf -g -o hello.o test.asm

link the resulting object to executable:

    ld -o hello.out hello.o -lc -dynamic-linker /lib/ld-linux-x86-64.so.2

run:

    ./hello.out

or use shorthand:

    cargo r && nasm -f elf64 -F dwarf -g -o hello.o out.asm && ld -o hello.out hello.o -lc -dynamic-linker /lib/ld-linux-x86-64.so.2 && ./hello.out

# Parsing
Currently recursive descent that generates reverse polish notation type flat tree `Soken`'s
Correctness of balanced delimiters ([{}]) is controlled by lexer.

```
<PROGRAM> ::= <STATEMENT>*
<STATEMENT> ::= <FN_DEF> | <CREATE_VAR> | <IF> | <WHILE> | <RETURN> | <SCOPE> | <STATEMENT_EXPR>

<FN_DEF> ::= [fn] [ident] [(] ([ident] [,]))* [)] <SCOPE>
(except last comma)
<CREATE_VAR> ::= [let] [ident] <EXPR> [;]
<IF> ::= [if] <EXPR> <SCOPE>
<WHILE> ::= [while] <EXPR> <SCOPE>
<RETURN> ::= [ret] <EXPR> [;]
<SCOPE> ::= [{] <STATEMENT>* [}]
<STATEMENT_EXPR> ::= ([ident] | [int] | [string]) <EXPR> [;]

<EXPR> ::= (<PRIMARY> [binop])* ([;] | [}] | [)] | [{])
<PRIMARY> ::= [string] | [int] | ([(] <EXPR>) | <FUNC_CALL> | [ident] (no following [(])
<FUNC_CALL> ::= [ident] [(] (<EXPR> [,])* [)]
(except last comma)
```

# Flat syntax tree shenanigans
thought - let everything collapse right into operators like shunting yard algorithm

ex: [1][2][+] -> [3]

or: [2][3][*][1][+] -> [7]

SYNTAX FOR THIS SECTION: [XYZ] around means the XYZ is some kind of token stored in an array

[XYZ]* means 0 or more of XYZ

[XYZ]+ means 1 or more of XYZ

**FUNCTION_CALL**: (later could remove that calls hold nr of arguments, could be implicit)
```
f(1,2)
-> [1] [2] [call f 2args]
<FN_CALL> ::= <EXPR>* [FuncCall(ident, nr_args)]
```
(returns what the function got)

### ALL the following return NOTHING: (not even Unit)

**CREATE_VAR**:
```
let a = 2;
->  [create_var a] [a][2][=]           two statements
FORM: [CreateVar(ident: a)] <EXPR>
or actual:
let b;
-> [CreateVar(ident)]
<CREATE_VAR> ::= [CreateVar(ident)]
```
(problem with this is you can reference the variable in the definition: let x=x)


**SEMICOLON**:  (consumes value)
```
1+2;
-> [1][2][+][;]
FORM: <EXPR> [;]
```

**SCOPES**:
```
a=2;{a=3;}
-> [a][2][=] [{] [a][3][=] [}]
<SCOPE> ::= [{] <EXPR>* [}]
```

**RETURN**:
```
return 1+2*3;
->   [2][3][*][1][+][ret]       one statement
<RETURN> ::= [EXPR] [ret]
```

**WHILE**:
```
while 1 {g(2);}
->  [1] [while] [2] [call g 1arg] [}]
<WHILE> ::= <EXPR> [while] <EXPR>* [}]
```
(condition first)

**IF**:
```
if 420 {return 2;}
->    [420] [if] [2] [ret] [}]
<IF> ::= <EXPR> [if] <EXPR>* [}]
```
(good that if isn't succeded by {, as this would be unnecessary, also that block is different, as returns guaranteed)


**FN_DEF**: (get nbr of args from hashmap (functions))
```
fn f(a,b) {return 3} fn g(a,b) {f(1,2);return 4;}
->  [def f 2arg] [a] [b] [3] [ret] [}]  [a] [b] [def g 2arg] [1] [2] [call f 2arg] [4] [ret] [}]
<FN_DEF> ::=  [func_def_ident] [ident]* <EXPR>* [}]
```

Making an API to look at this: TODO

# Troubles:
On linux, when you run a program it is by default line buffered (input sent on \n),
but when I tried to pipe input (./prog > lefile) the file got nothing.
This was because piping changes the buffering so it only sends data when the buffer is full.
This was fixed by calling `fflush(stdout)` at the end of _start

# OLD syntax
```
FORM $myvar === 343 + 34
$myvar === @add(1,2)
$string === "my string"
IF $myvar = 34 {
    @print(myvar)
}
```
